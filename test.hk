(* foo f g = g (f 1); *)

(* destructure : Structure -> X; *)
(* destructure (Structure x) = x; *)

(* isTrue True = True; *)
(* isTrue _ = False; *)

(* isFive 5 = True; *)
(* isFive _ = False; *)

(* isHello ("Hello!") = True; *)
(* isHello _ = False; *)

(* Cons : A -> B -> Cons; *)
(* head : Cons -> A; *)
(* head (Cons x xs) = x; *)
(* head Nil = undefined; *)

(* head (x::xs) = x; *)
(* head [] = undefined; *)

(* length (x::xs) = 1 + length xs; *)
(* length [] = 0; *)

(* isSingleton [x] = True; *)
(* isSingleton _ = False; *)

(* a + b = add a b; *)

(* oneInt = 1; *)
(* oneFloat = 1.0; *)

(* takesInt 1 = True; *)
(* takesInt _ = False; *)

(* takesFloat 1.0 = True; *)
(* takesFloat _ = False; *)

(* three = let x = 3 in x; *)

(* someTuple = let f = id in (f 3, f True); *)

(* lambda = \x -> x; *)

(*
example1 =
    let id = \x ->
        let y = x in y
    in id id;
*)

example2 =
    \m ->
        let y = m in
            let x = y True in x;

(* foo = \x -> \y -> let z = y in z; *)

(* bar : Int -> Int; *)
bar = \x -> x + 123;

(* t = True; *)

(* id : a -> a; *)
id = \b -> b;

(* @Fixme: *)
(* foo = \x y -> (x (y+100)) - 100; *)
foo = \x y -> (x (y + 100)) - 100;

(* simpleIllTyped = (\x -> x 123) 456; *)

(* infiniteTyped x = x x; *)
