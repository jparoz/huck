(* foo = let a = 123 *)
(*         in let b = a + 456 *)
(*             in let a = "Hello" *)
(*                 in a; *)

(* not True = False; *)
(* not False = True; *)


(* True && True = True; *)
(* _ && _ = False; *)
(* infixr 3 &&; *)

(* False || False = False; *)
(* _ || _ = True; *)
(* infixr 2 ||; *)

(* boolA = (True && False) || True; *)
(* boolB = True && (False || True); *)
(* boolC = True && False || True; *)

(* bothAreTrue a b = a && b; *)


infixl 6 +;
infixl 7 *;

numA = 3 + 4 * 5;
numB = 3 * 4 + 5;


(* valA = valB + 1; *)
(* valB = valA + 1; *)

(* mutualA 0 = 0; *)
(* mutualA x = mutualB x - 1; *)

(* mutualB 0 = 0; *)
(* mutualB x = mutualA x - 1; *)

(* id1 = \a -> a; *)
(* id2 a = a; *)

(* const a b = a; *)

(* bar any 0 = 0; *)
(* bar x y = x / y; *)

(* usesUnit : () -> String *)
(* usesUnit () = "foo"; *)

(* returnsUnit : ∀a. a -> () *)
(* returnsUnit x = (); *)

(* unitArgument : ∀a. a -> String *)
(* unitArgument x = usesUnit (); *)

(* compileError : COMPILE ERROR *)
(* compileError x = usesUnit 123; *)

(* baz "hello" = "goodbye"; *)
(* baz s = s ++ "."; *)

(* quux (Just 1) = 1; *)
(* quux (Just x) = x + 2; *)
(* quux Nothing = 123; *)

(* addIfOne [1, x] = 1 + x; *)
(* addIfOne [_, x] = x; *)

(* tuple = (1, "hi"); *)

(* usesTuple (n, s) = (n*2, s .. s); *)

(* callsTheTupleFunctionA = usesTuple (123, "cat"); *)
(* callsTheTupleFunctionB = usesTuple tuple; *)

(* shouldBeLast = shouldBeNext + 123; *)

(* mustComeFirst = 456; *)

(* shouldBeNext = mustComeFirst + 2; *)

(* usesCyclic = cyclicA; *)
(* cyclicA = cyclicB; *)
(* cyclicB = cyclicC; *)
(* cyclicC = cyclicA; *)
